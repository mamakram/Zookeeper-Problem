<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link href="style.css" rel="stylesheet" />
    <title>Zookeeper</title>
  </head>
  <body>
    <div class="tab">
      <button class="tablinks active" onclick="openTab(event, 'Explanation')">
        Explanation
      </button>
      <button class="tablinks" onclick="openTab(event, 'Demo')">Demo</button>
      <button class="tablinks" onclick="openTab(event, 'References')">
        References
      </button>
    </div>

    <!-- Tab content -->
    <div id="Explanation" class="tabcontent">
      <h2 style="text-align: center" class="titleHead">
        Zookeeper problem: Solving the zookeeper algorithm in approximatively
        O(n²)
      </h2>
      <div style="text-align: center" class="author">
        <span class="cmr-12"
          >Amir M. Fallahi, Anthony Kerckhof, Markus Makram Ghatas
        </span>
      </div>
      <br />
      <div style="text-align: center" class="date">
        <span class="cmr-12">November 2021</span>
      </div>
      <h3 class="sectionHead">
        <span class="titlemark">1 </span> <a id="x1-10001"></a>Preamble
      </h3>
      <!--l. 7-->
      <p class="noindent" align="justify"></p>
      <h4 class="subsectionHead">
        <span class="titlemark">1.1 </span> <a id="x1-20001.1"></a>What is the
        Zookeeper&#8217;s Problem
      </h4>
      <!--l. 8-->
      <p class="noindent" align="justify">
        Let P be a simple polygon representing a zoo. From now on, we will call
        this polygon the Zoolygon.<br class="newline" />
        Let C<sub><span class="cmr-7">1</span></sub
        >,...,C<sub><span class="cmmi-7">k</span></sub> be a set of k disjoint
        convex hulls in P such that each convex hull shares an edge with our
        Zoolygon. These are the cages of our zoo.<br class="newline" />
        Let p be a vertex of P representing a zoo-keeper&#8217;s chair.<br
          class="newline"
        />The zoo-keeper&#8217;s problem is to find the shortest closed path
        starting at p and touching at least one point of each cage without
        entering them. This path is a shortest path that the zoo-keeper can take
        to feed all the animals.
        <!--l. 11-->
      </p>

      <p class="noindent" align="justify"></p>
      <h4 class="subsectionHead">
        <span class="titlemark">1.2 </span> <a id="x1-30001.2"></a>Objective
      </h4>
      <!--l. 12-->
      <p class="noindent" align="justify">
        The aim of this website is to provide an algorithm that solves the
        Zookeeper&#8217;s algorithm on a predefined Simple Polygon.<br
          class="newline"
        />For this, the user will be provided an environment to place cages in a
        Zoo and then find the shortest path from a chosen vertex.
        <!--l. 15-->
      </p>

      <p class="noindent" align="justify"></p>
      <h3 class="sectionHead">
        <span class="titlemark">2 </span> <a id="x1-40002"></a>Environment
      </h3>
      <!--l. 16-->
      <p class="noindent" align="justify"></p>
      <h4 class="subsectionHead">
        <span class="titlemark">2.1 </span> <a id="x1-50002.1"></a>Description
      </h4>
      <!--l. 17-->
      <p class="noindent" align="justify">
        The environment given to the user consists of a canvas containing our
        Zoolygon (Zoo polygon). Here, the user is able to place as many cages as
        they wish by selecting points first on the polygon edges then inside to
        form a convex hull across an edge. The createCage button then creates
        said convex hull.<br class="newline" />
      </p>

      <h4 class="subsectionHead">
        <span class="titlemark">2.2 </span>
        <a id="x1-60002.2"></a>Implementation
      </h4>
      <!--l. 19-->
      <p class="noindent" align="justify">
        To implement these features, a few things are necessary:<br
          class="newline"
        />
      </p>

      <ul class="itemize1">
        <li class="itemize">
          A way to reflect a point on a line, for selection of points across
          polygon edges
        </li>
        <li class="itemize">
          A way to compute the polygonal chain between two points on the Polygon
          (i.e all the vertices of the Polygon between these to points) as well
          as ways to ensure the convexity of this chain
        </li>
        <li class="itemize">
          A way to then compute the rest of the Convex hull of a cage with this
          polygonal Chain
        </li>
      </ul>
      <!--l. 25-->
      <p class="noindent" align="justify">
        This implementation therefore has a lot of edge cases that have to be
        handled to restrict point placement in order to create only convex Cages
        on the Polygon.
      </p>

      <h3 class="sectionHead">
        <span class="titlemark">3 </span> <a id="x1-70003"></a>Shortest Path in
        a Simple Polygon
      </h3>
      <!--l. 27-->
      <p class="noindent" align="justify"> 
        The shortest path between two points in a simple polygon is the first step that should be implemented to solve the problem. In order to compute such a shortest path, we first need to find a path (not necessarily the shortest one) that connects the two points. So as to find this path, we should compute the dual graph of the polygon. The dual is a graph of triangles, in form of a tree. There exists a connection between two triangles in the dual if those two triangles share an edge in the triangulated polygon.
        <br class="newline"/>  
        <br class="newline"/>  
        What interests us in the dual tree is the path between two special triangles of the triangulation : those which have an endpoint of the shortest path inside them. We find this path using the DFS in the graph, note that this path is unique because we consider a tree.
        <br class="newline"/>  
        <br class="newline"/>  
        Now that we have a path inside our original polygon, we can proceed to the funnel algorithm.
        To do so, we first compute the list of segments of triangles crossed by our path. Then, advancing through our path, each time we cross one segment of this list with our path, we can update boundaries on the shortest path using the endpoints of the segment we crossed.
        </p>
        <h4 class="subsectionHead">
          <span class="titlemark"> 3.1 </span> <a id="x1-50002.1"></a>Basic Notions
        </h4>
        <p class="noindent" align="justify">
          Before we explain the funnel algorithm, let's check some notions together.
          <ul class="itemize1">
            <li class="itemize">
              First notion that we should know about is Topology. Topology refers to properties of geometric object which is unchangeable. For example consider a tape, the tape form is preservable against stretching, twisting, crumpling and bending but it is changeable against tearing. Topological space is a set of objects which has topological properties.<br>
            </li>
            <li class="itemize">
              Second interesting notion is homotopy. Two continous functions f, g from topological space X, to topological space Y are homotopic, if f can be continuously convert to g or if g can be continuously convert to f, such a conversion is called homotopy.
            </li>
          </ul>        
         </p>
        <br class="newline"/>  
        <br class="newline"/> 
        <center>
        <figure>
          <img src="https://upload.wikimedia.org/wikipedia/commons/7/7e/HomotopySmall.gif" width = "20%"/>
          <a href="https://en.wikipedia.org/wiki/Homotopy">
          <figcaption>Example of two homotopic functions</figcaption>
          </a>
        </figure>
        </center>
        <br>
        <p class="noindent" align="justify">
        So why these notions are important ? Let's return to our problem. Considering our shortest path problem and knowing an initial path, it can be shortened by pulling on it like a rope, while preserving its topology. This is exactly the logic behind the funnel algorithm.
      </p>
      <h4 class="subsectionHead">
        <span class="titlemark"> 3.2 </span> <a id="x1-50002.1"></a>Funnel Algorithm
      </h4>
      <p class="noindent" align="justify">
        Given a triangulated polygon, the source point, the destination point and an initial path p from the source to the destination. Our goal is to find the shortest homotopic path to p which goes from the source to the destination. Maybe you wonder why the algorithm is called funnel. In fact the algorithm is composed of two boundaries, a left side boundary and a right side boundary. These two boundaries are connected to each other from one endpoint (source point at the beginning) which creates an image similar to a funnel.
        <br class="newline"/>  
        <br class="newline"/>
        At each iteration we try to tighten the bottleneck of this funnel in respect to the edges that have been crossed by path p (green). Once the left side boundary coincides on the right side boundary or vice versa, we found a portion of the shortest path and we restart the funnel process from the last point of this portion (this point is called the apex) until we reach the destination point.
        <br class="newline"/>  
        <br class="newline"/>
        Consider the following example, 
      </p> 
        <br class="newline"/>  
        <center>
        <figure>
          <img src="./images/Funnel_Base.jpg" width = "20%"/>
          <figcaption>Basic Example</figcaption>
        </figure>
        </center>
        <br class="newline"/> 
      <p class="noindent" align="justify">
        The dotted line represents the path p, green segments represent triangulation edges that have been crossed by the path p and purple segments are other edges of the triangulation. Let's take a look at each iteration of the algorithm :
        <br class="newline"/>
        <br class="newline"/>  
        <b>Iteration 1: </b> At the beginning we connect the apex (source point) of our funnel to the endpoints of the first edge which has been crossed by path p (AH). The right boundary is represented in blue and the left boundary in red. 
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it1.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 2: </b> In order to tighten our funnel by considering the second crossed edge (AG), we move the left boundary endpoint from H to G as there exists a direct path from the apex to G. The right boundary is already on A so it is not possible to move it.
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it2.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 3: </b> Now in order to tighten our funnel by considering the next crossed edge (BG), we can not move the left boundary, as it is at the left most position compared to the apex and respecting to BG. The right boundary also is not movable as the endpoint of the next edge (B) is at its right side (or at least it is aligned with it) but it is possible to continue the right boundary on the edge (AB) in order to reach the next endpoint.
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it3.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 4: </b> Now the next crossed edge is BF and it is possible to move the left boundary to tighten the funnel (From G to F).
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it4.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 5: </b> In order to handle the next crossed edge (CF), it is not possible to move the right boundary (as it is at the right most position compared to the apex). The only way to continue the execution is to move the left boundary. As we move this boundary it will be coincide over the right boundary. So the coincide segment will be a part of the solution. This shared segment is the tail of our funnel and its endpoint (B) which is closer to the destination is the new apex. 
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it5.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 6: (pas une itération) </b> Now we got new left boundary and new right boundary; As you can see there is a possibility to move the right boundary to tighten the new funnel by considering the edge CF.
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it6.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 7: </b> Next crossed edge is DF and we can again move the right boundary to tighten the funnel .
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it7.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 8: </b> We can once again move the right boundary to tighten the funnel and handle the crossed edge EF.
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it8.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 9: </b> The final step is particular : 
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_it9.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        You can see the final solution of funnel algorithm below:
      </p>
      <br class="newline"/>   
      <center>
        <img src="./images/F_sol.jpg" width="20%"/>
      </center>  
      <br class="newline"/> 


      <h3 class="sectionHead">
        <span class="titlemark">5 </span> <a id="x1-80004"></a> General look of a zookeeper's path<!--  -->
      </h3>
      <p class="noindent">
        Wei-Pang Chin and Simeon Stafos stated in (faudra faire une ref) the following lemma : <br>
      
        <div style="background: ghostwhite; 
            font-size: 16px; 
            padding: 10px; 
            border: 1px solid lightgray; 
            margin: 10px;">

            <p>
              <span class="underline">Lemma </span>: <br>
              Let s = C<sub>0</sub> , C<sub>1</sub> , ...,  C<sub>k</sub>  be the order in which s and the convex polygons in the set of cages are first visited in a counterclockwise scan of the boundary of P (the zoo). <br>
              Then there is a shortest zookeeper route that visits the cages in the set of cages in that same order. <br>
  
            </p>
            
        </div>
      </p>
      <p class="noindent">
        This is actually quite easy to figure out. <br>
        Imagine it's not true and there is a shortest zookeeper's route that intersects itself at some point. (cfr. figure below) 
         
        <center>
        <figure>
          <img src="./images/generalLook1.png" width = "30%"/>
          <figcaption>Zookeeper's route intersecting itself</figcaption>
        </figure>
        </center>
        <br class="newline"/> 
      </p>

      <p class="noindent">
        In such a path, the intersection create two triangles which are clossed by the dotted lines in the next figure. <br>
        We realize that for both of such triangles, we consider the two sides that are not the hypotenuse instead of the hypotenuse, which is obviously not the shortest path. <br> 
        <center>
        <figure>
          <img src="./images/generalLook2.png" width = "30%"/>
          <figcaption> Triangles created by intersection </figcaption>
        </figure>
        </center> 
        <br class="newline"/> 
      </p>

      <p class="noindent">
        As the length of the hypotenuse of a triangle is always shorter than the sum of the lengths of the two other sides, and as all cages are still considered in the new path, 
        we can shorten the zookeeper's route by passing through the two hypotenuses we did not consider before. <br>
        Therefore, a route that intersects itself cannot exist, we get that the shortest route is considered in the order the cages are given on the boundary of the polygon, from s to s.  
        <center>
        <figure>
          <img src="./images/generalLook3.png" width = "30%"/>
          <figcaption> Shortend zookeeper's route </figcaption>
        </figure>
        </center>
        <br class="newline"/> 
      </p>

      <h3 class="sectionHead">
        <span class="titlemark">6 </span> <a id="x1-80004"></a> First approximation of shortest zookeeper's route.
      </h3>
      <p>
        <h4 class="subsectionHead">
          <span class="titlemark">6.1 </span> <a id="x1-50002.1"></a>Supporting chains
        </h4>
        <p>
          Now that we know in which order we have to consider the cages of the zoo, let us introduce another tool we need to compute the zookeeper's path : the supportings chains. <br>
          A supporting chain is a chain defined between two cages, C<sub>i</sub> and C<sub>i+1</sub> that goes from the starting vertex of C<sub>i</sub> to the last vertex of C<sub>i+1</sub>. <br>
          In particular, this chain is the shortest path between those two points. We compute it using the funnel algorithm.<br>
          Let us aswell define two points, let b := the point of the chain leaving the cage C<sub>i</sub>, and let a := the first point to touch C<sub>i+1</sub>.
          <center>
            <figure>
              <img src="./images/suppChain.png" width = "30%"/>
              <figcaption> Illustration of a supporting chain </figcaption>
            </figure>
            </center>
            <br class="newline"/> 


          
        
        </p>
        
        <h4 class="subsectionHead">
          <span class="titlemark">6.2 </span> <a id="x1-50002.1"></a> Identification of the edges of the cage where the shortest route passes
        </h4>
        <p>
          We will now use those supporting chains to identify, for each cage, the edge considered in the final shortest zookeeper's route. <br>
          To do so, we compute the supporting chains from C<sub>i</sub> to C<sub>i+1</sub>, where s is consider to be C<sub>0</sub> and C<sub>n+1</sub> for all of our n cages. In particular, this identify the points a and b for each cage.<br>
          We can now interest ourselfs in another lemma stated by Chin and Ntafos : <br>

          <div style="background: ghostwhite; 
            font-size: 16px; 
            padding: 10px; 
            border: 1px solid lightgray; 
            margin: 10px;">

            <p>
              <span class="underline">Lemma </span>: <br>
            If a &#8805; b, then any shortest zookeeper's route R either reflects on a point between a and b, or it wraps around C<sub>i</sub> and has at least one point of contact between a and b. <br>
            If a &#60; b, all points between a and b are also in R.<br>
            </p>
          
        </div>
        <p>
          Let represent us what this lemma claims :  <br>
          <center>
            <figure>
              <img src="./images/exempleAB.png" width = "25%"/>
              <figcaption> Illustration of a supporting chain </figcaption>
            </figure>
            </center>
            <br class="newline"/>  
        </p>
        <p>
          For C<sub>2</sub> and C<sub>3</sub> : a comes after b. Therefore, the final zookeeper's route will hit those cages somewhere between a and b. <br>
          For C<sub>1</sub> : a comes before b. Therefore, all points between a and b for C<sub>1</sub> are part of the final zookeeper's route. <br>
        </p>

        <p>
          Now let convince us that the lemma is true : <br class="newline"/>  
        <ul class="itemize1">
          <li class="itemize">
            For a &#8805; b, imagine the zookeper's route does not reflect between the two points. Then, the zookeeper's route must wrap around at least one of the two points of the cage to reach the next cage, which would create a longer path and contradict the lemma.<br>
          
          </li>
          <li class="itemize">
            For a &#60; b, the only way not to consider all the points between a and b is to break contact and then return to the chain, which creates a longer route.<br>
          As we know that the cages are to be considered in the order of the boundary of the zoo, we cannot access the cage from another point than a (which is the closest from the last cage) as it would create a longer route aswell. <br>
          
          </li>
          
        </ul>
        <p>
          The whole lemma is therefore true.
        </p></p></p>
        
        <p>
          Implication of this lemma :
          <div style="background: ghostwhite; 
            font-size: 16px; 
            padding: 10px; 
            border: 1px solid lightgray; 
            margin: 10px;">

            <p>
             
            Cages where a &#60; b can be treated as obstacles to the path as the funnel between the cage before and the cage after will consider all the points of this cage correctly anyway.<br>
            </p>
          
        </div>
      
      
      </p>

      <h4 class="subsectionHead">
        <span class="titlemark">6.3 </span> <a id="x1-50002.1"></a> Computation of R0, the first approximation of the shortest route.
         TO BE DONE
      </h4>
      
      <h3 class="sectionHead">
        <span class="titlemark">7 </span> <a id="x1-80004"></a>Zookeeper
        algorithm
      </h3>
    </div>

    <div id="Demo" class="tabcontent">
      <h3>Demo</h3>
      <p>
        Rules: Place the desired number of Cages (a.k.a convex hulls) on the
        Polygon.
      </p>
      <p>
        Start by placing two points on the Polygon edges (these points must form
        a convex chain of vertices across the Polygon).
      </p>
      <p>
        Then, place as many points as you want inside the Polygon, press create
        Cage when done to form a convex Cage with the set of points and the two
        points on the Polygon
      </p>

      
      <div id="messages ">
        <p id="Info"></p>
        <p style="min-height: 40px; color: red" id="Error"></p>
      </div>

      <p>
        NOTE: 
        The Show Funnel button is a temporary button for the funnel algorithm in developpement. 
        It displays :
        <ul class="itemize1">
          <li class="itemize">
            the triangulation of the polygon,
          </li>
          <li class="itemize">
            the approximate shortest path between the 2 fixed points s and t (in red), 
          </li>
          <li class="itemize">
            the segments crossed by the path (in green)
          </li>
        </ul>
        The actual shortest path is still to be computed using the funnel algorithm.

      </p>

      <div id="buttons">
        <button class="button1" onclick="createCage()" id="crCage">
          Create Cage
        </button>
        <button class="button1" onclick="reset()" id="rst">Clear</button>
        <button class="button1" onclick="showFunnel()" id="funnel">
          Show Funnel
        </button>
        <button class="button1" onclick="showSupportingChains()" id="suppCages">
          Debug : show suppChains
        </button>
        <button class="button1" onclick="swap()" id="swap">
          Swap SuppChain / R0
        </button>
      </div>
      <div id="scriptContainer">
        <script
          src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.5/math.js"
          integrity="sha512-R+I48DmxDONCcV2MyhKKVv9QYPzcmoSdNYBDNmHoJh2R4g6mqakFTBiIMYU9r/T0kK8y5Q/JvlQ8iRb5DdHV/A=="
          crossorigin="anonymous"
          referrerpolicy="no-referrer"
        ></script>
        <script src= "https://unpkg.com/earcut@2.2.3/dist/earcut.min.js"></script>

        <script src="https://cdn.jsdelivr.net/npm/p5@1.0.0/lib/p5.js"></script>

        <script type="module" src="Main.js"></script>

        <noscript>Sorry, your browser does not support JavaScript!</noscript>
      </div>
    </div>

    <div id="References" class="tabcontent">
      <h3>References</h3>
      <h4>Zookeeper Algorithm</h4>
      <a
        href="https://www.sciencedirect.com/science/article/pii/S0925772102000925"
        >An O(nlogn) algorithm for the zoo-keeper's problem,Sergei
        Bespamyatnikh</a
      > <br/>
      <a
        href="https://www.sciencedirect.com/science/article/abs/pii/002002559290072G"
        >The zookeeper route problem, Chin & Ntafos
      </a
      >

      
      <h4>Shortest path</h4>
      <a href="https://www.cc.gatech.edu/~rpeng/18434_S15/sspPolygon.pdf"
        >Georgia Tech - Seminar in Theoretical Computer Science : Shortest Path
        in a Polygon, Alex Grinman
      </a>
      <br />
      <a
        href="https://www.sciencedirect.com/science/article/pii/0925772194900108?via%3Dihub"
        >Computing minimum length paths of a given homotopy class,John
        Hershberger & Jack Snoeyink</a
      >
    </div>

    <!-- script to open tabs-->
    <script>
      function openTab(evt, tabName) {
        var i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
          tabcontent[i].style.display = "none";
        }
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
          tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(tabName).style.display = "block";
        evt.currentTarget.className += " active";
      }
      document.getElementById("Explanation").style.display = "block";
    </script>
  </body>
</html>
