<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link href="style.css" rel="stylesheet" />
    <title>Zookeeper</title>
  </head>
  <body>
    <div class="tab">
      <button class="tablinks active" onclick="openTab(event, 'Explanation')">
        Explanation
      </button>
      <button class="tablinks" onclick="openTab(event, 'Demo')">Demo</button>
      <button class="tablinks" onclick="openTab(event, 'References')">
        References
      </button>
    </div>

    <!-- Tab content -->
    <div id="Explanation" class="tabcontent">
      <h2 style="text-align: center" class="titleHead">
        Zookeeper problem: Solving the zookeeper algorithm in approximatively
        O(nlogn)
      </h2>
      <div style="text-align: center" class="author">
        <span class="cmr-12"
          >Amir M. Fallahi, Anthony Kerckhof, Markus Makram Ghatas
        </span>
      </div>
      <br />
      <div style="text-align: center" class="date">
        <span class="cmr-12">November 2021</span>
      </div>
      <h3 class="sectionHead">
        <span class="titlemark">1 </span> <a id="x1-10001"></a>Preamble
      </h3>
      <!--l. 7-->
      <p class="noindent" align="justify"></p>
      <h4 class="subsectionHead">
        <span class="titlemark">1.1 </span> <a id="x1-20001.1"></a>What is the
        Zookeeper&#8217;s Problem
      </h4>
      <!--l. 8-->
      <p class="noindent" align="justify">
        Let P be a simple polygon representing a zoo. From now on, we will call
        this polygon the Zoolygon.<br class="newline" />
        Let C<sub><span class="cmr-7">1</span></sub
        >,...,C<sub><span class="cmmi-7">k</span></sub> be a set of k disjoint
        convex hulls in P such that each convex hull shares an edge with our
        Zoolygon. These are the cages of our zoo.<br class="newline" />
        Let p be a vertex of P representing a zoo-keeper&#8217;s chair.<br
          class="newline"
        />The zoo-keeper&#8217;s problem is to find the shortest closed path
        starting at p and touching at least one point of each cage without
        entering them. This path is a shortest path that the zoo-keeper can take
        to feed all the animals.
        <!--l. 11-->
      </p>

      <p class="noindent" align="justify"></p>
      <h4 class="subsectionHead">
        <span class="titlemark">1.2 </span> <a id="x1-30001.2"></a>Objective
      </h4>
      <!--l. 12-->
      <p class="noindent" align="justify">
        The aim of this website is to provide an algorithm that solves the
        Zookeeper&#8217;s algorithm on a predefined Simple Polygon.<br
          class="newline"
        />For this, the user will be provided an environment to place cages in a
        Zoo and then find the shortest path from a chosen vertex.
        <!--l. 15-->
      </p>

      <p class="noindent" align="justify"></p>
      <h3 class="sectionHead">
        <span class="titlemark">2 </span> <a id="x1-40002"></a>Environment
      </h3>
      <!--l. 16-->
      <p class="noindent" align="justify"></p>
      <h4 class="subsectionHead">
        <span class="titlemark">2.1 </span> <a id="x1-50002.1"></a>Description
      </h4>
      <!--l. 17-->
      <p class="noindent" align="justify">
        The environment given to the user consists of a canvas containing our
        Zoolygon (Zoo polygon). Here, the user is able to place as many cages as
        they wish by selecting points first on the polygon edges then inside to
        form a convex hull across an edge. The createCage button then creates
        said convex hull.<br class="newline" />
      </p>

      <h4 class="subsectionHead">
        <span class="titlemark">2.2 </span>
        <a id="x1-60002.2"></a>Implementation
      </h4>
      <!--l. 19-->
      <p class="noindent" align="justify">
        To implement these features, a few things are necessary:<br
          class="newline"
        />
      </p>

      <ul class="itemize1">
        <li class="itemize">
          A way to reflect a point on a line, for selection of points across
          polygon edges
        </li>
        <li class="itemize">
          A way to compute the polygonal chain between two points on the Polygon
          (i.e all the vertices of the Polygon between these to points) as well
          as ways to ensure the convexity of this chain
        </li>
        <li class="itemize">
          A way to then compute the rest of the Convex hull of a cage with this
          polygonal Chain
        </li>
      </ul>
      <!--l. 25-->
      <p class="noindent" align="justify">
        This implementation therefore has a lot of edge cases that have to be
        handled to restrict point placement in order to create only convex Cages
        on the Polygon.
      </p>

      <h3 class="sectionHead">
        <span class="titlemark">3 </span> <a id="x1-70003"></a>Shortest Path in
        a Simple Polygon
      </h3>
      <!--l. 27-->
      <p class="noindent" align="justify"> 
        The shortest path in a simple polygon is the first step that should be implemented. We should find the shortest path between all cages. To do so, we compute the dual graph of the polygon. The dual is a graph of triangles, in form of a tree. There exist an edge between two triangles in the dual, if those two triangles share an edge in the triangulated polygon.
        <br class="newline"/>  
        <br class="newline"/>  
        What interests us in the dual tree is the path between two special triangles of the triangulations : those who have an endpoint of the shortest path inside them. We find this path using a DFS in the graph.
        <br class="newline"/>  
        <br class="newline"/>  
        Now that we have an approximatively shortest path inside our original polygon, we can proceed the funnel algorithm.
        To do so, we first compute the list of segments of triangles crossed by our path. Then, following our path, each time we cross one segment of this list with our path, we can update boundaries on the shortest path using the endpoints of the segment we crossed.
        </p>
        <br class="newline"/>  
        <br class="newline"/> 
        <h4 class="subsectionHead">
          <span class="titlemark"> 3.1 </span> <a id="x1-50002.1"></a>Basic Notions
        </h4>
        <p class="noindent" align="justify">
        Before we explain the funnel algorithm, Let's check some notions together; First notion that we should know about it, is Topology; Topology refers to properties of geometric object which is unchangable versus continous mapping; For example consider a tape; The tape form is preservable against scretching, twisting, crumpling and bending but it is changable against tearing. Topological space is a set of objects which has topological properties. Second instersting notion is homotopy; Two continous functions f, g from topological space X, to topological space Y are homotopic, if f can be continuously convert to g or if g can be continuously convert to f. Such a conversion is called homotopy; In order to understand better check the example of Wikipedia in the gif below:
        </p>
        <br class="newline"/>  
        <br class="newline"/> 
        <center>
        <figure>
          <img src="https://upload.wikimedia.org/wikipedia/commons/7/7e/HomotopySmall.gif" width = "20%"/>
          <a href="https://en.wikipedia.org/wiki/Homotopy">
          <figcaption>Two homotopic functions </figcaption>
          </a>
        </figure>
        </center>
        <br class="newline"/>  
        <br class="newline"/> 
        <p class="noindent" align="justify">
        So why these notions are important ? Let's return to our own problem. we are searching for the shortest path that zookeeper must traversed without entering into the cages; If we found the shortest path from the zookeeper's initial position to the first cage and then from the first cage to the second cage and so on untill the last cage to the zookeeper's initial position, we can claim that we found the shortest path that zookeper travered from an initial position, visited all cages and return to the same position by gathering all these shortest path that we found.
        <br class="newline"/>  
        <br class="newline"/>
        To find out these paths, let's imagine that there exist a path p from each cage to the next cage; Now we are interested to find the shortest path homotopic to the p; In fact the path p is the path that we found by using dfs algotithm (in the way that we explained at beginning of this section). Then we find the shortest path in the homotopy class of each p.
        <br class="newline"/>  
        <br class="newline"/>
      </p>
      <h4 class="subsectionHead">
        <span class="titlemark"> 3.2 </span> <a id="x1-50002.1"></a>Funnel Algorithm
      </h4>
      <p class="noindent" align="justify">
        Given a triangulated polygon, the source point, the destionation point and a path p from the source to the destination; Our goal is to find the shortest homotopic path to p which goes from the source to the destination. Maybe you wounder that why the algorithm is called funnel; In fact the algorithm is composed of two bounderies; a left side boundry and a right side boundry; The right side boundry and the left side boundry are connected to each other from one endpoint (source point at the beginning) which creates an image similar to a funnel.
        <br class="newline"/>  
        <br class="newline"/>
        At each iteration we try to tighten the bottleneck of this fuunel by respecting to the edges that have been crossed by path p (grren); Once the left side boundery coincide on the rigth side boundry, we found a segment of the shortest path and we restart the funnel process untill we reach the destination point.
        <br class="newline"/>  
        <br class="newline"/>
        Consider the following example, which make the explanation easier; 
      </p> 
        <br class="newline"/>  
        <br class="newline"/> 
        <center>
        <figure>
          <img src="./images/Funnel_Base.jpg" width = "20%"/>
          <figcaption>Basic Example</figcaption>
        </figure>
        </center>
        <br class="newline"/>  
        <br class="newline"/> 
      <p class="noindent" align="justify">
        The dotted line represents the path p, green segments represent triangulation edges that have been crossed by the path p and purple segments are other edges of the triangulation; The following picture shows each iteration. Let's discuss about each iteration:
      </p>
      <br class="newline"/>  
      <br class="newline"/> 
      <center>
      <figure>
        <img src="./images/Funnel_Execution_Labeled.jpg" width="75%"/>
        <figcaption>Funnel Algorithm Execution</figcaption>
      </figure>
      </center>
      <br class="newline"/>  
      <br class="newline"/> 
      <p class="noindent" align="justify">
        <b>Iteration 1: </b> At the beginning we connect the apex of our funnel (source point) to the endpoints of the edge which have been crossed by path p (AH).
        <br class="newline"/>  
        <b>Iteration 2: </b> In order to tighten our funnel by considering the first crossed edge (AH), we move the left boundry endpoint from H to G (right boundry is at the most right position compared to the apex [source] so it is not possible to move it).
        <br class="newline"/>
        <b>Iteration 3: </b> Now in order to tighten our funnel by considering the next crossed edge (AG), we can not move the left boundry (as it is at the left most position compared to the apex). The right boundry also in not movable as the endpoint of next edge (B) is at its right side (or at least it is aligned with it) but it is possible to continue the right boundry on the edge (AB) in order to reach the next endpoint (this will not tighten the funnel but it is the only way to continue execution; In fact the algorithm perform this action in same case).
        <br class="newline"/>
        <b>Iteration 4: </b> Now the next crossed edge is BG and it is possible to move the left boundry to tighten the funnel (From G to F).
        <br class="newline"/>
        <b>Iteration 5: </b> In order to handle the next crossed edge (BF), it is not possible to move the right boundry (as it is at the right most position compared to the apex). The only way to continue execution is to move the left boundry. As we move this boundry it will be coincide over the right boundry. So the coincide segment will be a part of the solution. This coincide segment is the the tail of our funnel and its endpoint which closer to the destination (B) is the new apex. 
        <br class="newline"/>
        <b>Iteration 6: </b> Now we got new left boundry and new right boundry; As you can see there is a possibility to move the right boundry to tighten the new funnel by considering the edge CF.
        <br class="newline"/>
        <b>Iteration 7: </b> Next crossed edge is DF and we can again move the right boundry to tighten the funnel .
        <br class="newline"/>
        <b>Iteration 8: </b> We can again move the right boundry to tighten the funnel and handle the crossed edge EF.
        <br class="newline"/>
        <b>Iteration 9: </b> We can again move the right boundry to tighten the funnel. So now we reached the destination; So our solution will be tail of the funnel with the boundry which have been reached the destination.
        <br class="newline"/>
      </p>


      <h3 class="sectionHead">
        <span class="titlemark">5 </span> <a id="x1-80004"></a> General look of a zookeeper's path<!--  -->
      </h3>
      <p class="noindent">
        Wei-Pang Chin and Simeon Stafos stated in (faudra faire une ref) the following lemma : <br>
      
        <div style="background: ghostwhite; 
            font-size: 16px; 
            padding: 10px; 
            border: 1px solid lightgray; 
            margin: 10px;">

            <p>
              <span class="underline">Lemma </span>: <br>
              Let s = C<sub>0</sub> , C<sub>1</sub> , ...,  C<sub>k</sub>  be the order in which s and the convex polygons in the set of cages are first visited in a counterclockwise scan of the boundary of P (the zoo). <br>
              Then there is a shortest zookeeper route that visits the cages in the set of cages in that same order. <br>
  
            </p>
            
        </div>
      </p>
      <p class="noindent">
        This is actually quite easy to figure out. <br>
        Imagine it's not true and there is a shortest zookeeper's route that intersects itself at some point. (cfr. figure below) 
         
        <center>
        <figure>
          <img src="./images/generalLook1.png" width = "30%"/>
          <figcaption>Zookeeper's route intersecting itself</figcaption>
        </figure>
        </center>
        <br class="newline"/> 
      </p>

      <p class="noindent">
        In such a path, the intersection create two triangles which are clossed by the dotted lines in the next figure. <br>
        We realize that for both of such triangles, we consider the two sides that are not the hypotenuse instead of the hypotenuse, which is obviously not the shortest path. <br> 
        <center>
        <figure>
          <img src="./images/generalLook2.png" width = "30%"/>
          <figcaption> Triangles created by intersection </figcaption>
        </figure>
        </center> 
        <br class="newline"/> 
      </p>

      <p class="noindent">
        As the length of the hypotenuse of a triangle is always shorter than the sum of the lengths of the two other sides, and as all cages are still considered in the new path, 
        we can shorten the zookeeper's route by passing through the two hypotenuses we did not consider before. <br>
        Therefore, a route that intersects itself cannot exist, we get that the shortest route is considered in the order the cages are given on the boundary of the polygon, from s to s.  
        <center>
        <figure>
          <img src="./images/generalLook3.png" width = "30%"/>
          <figcaption> Shortend zookeeper's route </figcaption>
        </figure>
        </center>
        <br class="newline"/> 
      </p>

      <h3 class="sectionHead">
        <span class="titlemark">6 </span> <a id="x1-80004"></a> First approximation of shortest zookeeper's route.
      </h3>
      <p>
        <h4 class="subsectionHead">
          <span class="titlemark">6.1 </span> <a id="x1-50002.1"></a>Supporting chains
        </h4>
        <p>
          Now that we know in which order we have to consider the cages of the zoo, let us introduce another tool we need to compute the zookeeper's path : the supportings chains. <br>
          A supporting chain is a chain defined between two cages, C<sub>i</sub> and C<sub>i+1</sub> that goes from the starting vertex of C<sub>i</sub> to the last vertex of C<sub>i+1</sub>. <br>
          In particular, this chain is the shortest path between those two points. We compute it using the funnel algorithm.<br>
          Let us aswell define two points, let b := the point of the chain leaving the cage C<sub>i</sub>, and let a := the first point to touch C<sub>i+1</sub>.
          <center>
            <figure>
              <img src="./images/suppChain.png" width = "30%"/>
              <figcaption> Illustration of a supporting chain </figcaption>
            </figure>
            </center>
            <br class="newline"/> 


          
        
        </p>
        
        <h4 class="subsectionHead">
          <span class="titlemark">6.2 </span> <a id="x1-50002.1"></a> Identification of the edges of the cage where the shortest route passes
        </h4>
        <p>
          We will now use those supporting chains to identtify, for each cage, the edge considered in the final shortest zookeeper's route. <br>
          To do so, we compute the supporting chains from C<sub>i</sub> to C<sub>i+1</sub>, where s is consider to be C<sub>0</sub> and C<sub>n+1</sub> for all of our n cages. In particular, this identify the points a and b for each cage.<br>
          We can now interest ourselfs in another lemma stated by Chin and Ntafos : <br>

          <div style="background: ghostwhite; 
            font-size: 16px; 
            padding: 10px; 
            border: 1px solid lightgray; 
            margin: 10px;">

            <p>
              <span class="underline">Lemma </span>: <br>
            If a &#8805; b, then any shortest zookeeper's route R either reflects on a point between a and b, or it wraps around C<sub>i</sub> and has at least one point of contact between a and b. <br>
            If a &#60; b, all points between a and b are also in R.<br>
            </p>
          
        </div>
        <p>
          Let represent us what this lemma claims :  <br>
          <center>
            <figure>
              <img src="./images/exempleAB.png" width = "25%"/>
              <figcaption> Illustration of a supporting chain </figcaption>
            </figure>
            </center>
            <br class="newline"/>  
        </p>
        <p>
          For C<sub>2</sub> and C<sub>3</sub> : a comes after b. Therefore, the final zookeeper's route will hit those cages somewhere between a and b. <br>
          For C<sub>1</sub> : a comes before b. Therefore, all points between a and b for C<sub>1</sub> are part of the final zookeeper's route. <br>
        </p>

        <p>
          Now let convince us that the lemma is true : <br class="newline"/>  
        <ul class="itemize1">
          <li class="itemize">
            For a &#8805; b, imagine the zookeper's route does not reflect between the two points. Then, the zookeeper's route must wrap around at least one of the two points of the cage to reach the next cage, which would create a longer path and contradict the lemma.<br>
          
          </li>
          <li class="itemize">
            For a &#60; b, the only way not to consider all the points between a and b is to break contact and then return to the chain, which creates a longer route.<br>
          As we know that the cages are to be considered in the order of the boundary of the zoo, we cannot access the cage from another point than a (which is the closest from the last cage) as it would create a longer route aswell. <br>
          
          </li>
          
        </ul>
        <p>
          The whole lemma is therefore true.
        </p></p></p>
        
        <p>
          Implication of this lemma :
          <div style="background: ghostwhite; 
            font-size: 16px; 
            padding: 10px; 
            border: 1px solid lightgray; 
            margin: 10px;">

            <p>
             
            Cages where a &#60; b can be treated as obstacles to the path as the funnel between the cage before and the cage after will consider all the points of this cage correctly anyway.<br>
            </p>
          
        </div>
      
      
      </p>

      <h4 class="subsectionHead">
        <span class="titlemark">6.3 </span> <a id="x1-50002.1"></a> Computation of R0, the first approximation of the shortest route.
         TO BE DONE
      </h4>
      
      <h3 class="sectionHead">
        <span class="titlemark">7 </span> <a id="x1-80004"></a>Zookeeper
        algorithm
      </h3>
    </div>

    <div id="Demo" class="tabcontent">
      <h3>Demo</h3>
      <p>
        Rules: Place the desired number of Cages (a.k.a convex hulls) on the
        Polygon.
      </p>
      <p>
        Start by placing two points on the Polygon edges (these points must form
        a convex chain of vertices across the Polygon).
      </p>
      <p>
        Then, place as many points as you want inside the Polygon, press create
        Cage when done to form a convex Cage with the set of points and the two
        points on the Polygon
      </p>

      
      <div id="messages ">
        <p id="Info"></p>
        <p style="min-height: 40px; color: red" id="Error"></p>
      </div>

      <p>
        NOTE: 
        The Show Funnel button is a temporary button for the funnel algorithm in developpement. 
        It displays :
        <ul class="itemize1">
          <li class="itemize">
            the triangulation of the polygon,
          </li>
          <li class="itemize">
            the approximate shortest path between the 2 fixed points s and t (in red), 
          </li>
          <li class="itemize">
            the segments crossed by the path (in green)
          </li>
        </ul>
        The actual shortest path is still to be computed using the funnel algorithm.

      </p>

      <div id="buttons">
        <button class="button1" onclick="createCage()" id="crCage">
          Create Cage
        </button>
        <button class="button1" onclick="reset()" id="rst">Clear</button>
        <button class="button1" onclick="showFunnel()" id="funnel">
          Show Funnel
        </button>
        <button class="button1" onclick="showSupportingChains()" id="suppCages">
          Debug : show suppChains
        </button>
        <button class="button1" onclick="swap()" id="swap">
          Swap SuppChain / R0
        </button>
      </div>
      <div id="scriptContainer">
        <script
          src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.5/math.js"
          integrity="sha512-R+I48DmxDONCcV2MyhKKVv9QYPzcmoSdNYBDNmHoJh2R4g6mqakFTBiIMYU9r/T0kK8y5Q/JvlQ8iRb5DdHV/A=="
          crossorigin="anonymous"
          referrerpolicy="no-referrer"
        ></script>
        <script src= "https://unpkg.com/earcut@2.2.3/dist/earcut.min.js"></script>

        <script src="https://cdn.jsdelivr.net/npm/p5@1.0.0/lib/p5.js"></script>

        <script type="module" src="Main.js"></script>

        <noscript>Sorry, your browser does not support JavaScript!</noscript>
      </div>
    </div>

    <div id="References" class="tabcontent">
      <h3>References</h3>
      <h4>Zookeeper Algorithm</h4>
      <a
        href="https://www.sciencedirect.com/science/article/pii/S0925772102000925"
        >An O(nlogn) algorithm for the zoo-keeper's problem,Sergei
        Bespamyatnikh</a
      >
      <h4>Shortest path</h4>
      <a href="https://www.cc.gatech.edu/~rpeng/18434_S15/sspPolygon.pdf"
        >Georgia Tech - Seminar in Theoretical Computer Science : Shortest Path
        in a Polygon, Alex Grinman
      </a>
      <br />
      <a
        href="https://www.sciencedirect.com/science/article/pii/0925772194900108?via%3Dihub"
        >Computing minimum length paths of a given homotopy class,John
        Hershberger & Jack Snoeyink</a
      >
    </div>

    <!-- script to open tabs-->
    <script>
      function openTab(evt, tabName) {
        var i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
          tabcontent[i].style.display = "none";
        }
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
          tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(tabName).style.display = "block";
        evt.currentTarget.className += " active";
      }
      document.getElementById("Explanation").style.display = "block";
    </script>
  </body>
</html>
